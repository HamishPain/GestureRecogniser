__author__ = 'Finch ThinkPad'

from binaryString import *
from hooplaDataParser import *
from timer import timeDelta
from random import choice, random, seed, shuffle
from drawer import *

#Best 6 neurons
bestLastGen = "010000111111111111111111111011110000000000000000010111000101001111110011011111110001010110111010001011111111111111111111111111110000000000000000111000111101010011100001110010000010001011011000110001111111111101111011111111110000000100000000101111001101111001011100000100100001110011110000110010000101001101011111011100111010000010100000110100010001010111010001110101000000010011111111011100000000010000000100000110001111111011101100100001111000000111111000010010110010101100000001111000000001100000000000000000001111101011111110111000111100100100011001011010100000110100001011"
bestLastGen = "010000111111111111111111111011110000000000000000010100000101001111110011011010110001010011011110001011111111111111111111111111110000000000001000010000111111111111100001110010000011111011111010110001111111111111111111011011110000000000000000101110101101111001011110000100100000100111110010110010000101011101011111011100111010000010100000110100010000010101010001010100000101010011101111010100000000010000000100000111001110111111111100111001110000110111111000010000000010101100000001111001000000100000000100000000001011110011111110111000111110101100011111011110000001110000001011"
bestLastGen = "010000111111111111111111111011110000000000000000010100000101001111110011011010110001010011011110001011111111111111111111111111110000000000001000010000111111111111100001110010000011111011111010110001111111111111111111011011110000000000000000101110101101111001011110000100100000100111100010110010000101011101011111011100111010000010100000110100010000010101110001010100000101010011101111010100000000010000000100000111001110111111111100111001110000110111111000010010000010101100000001111001000000100000000100000000001111110011111110111000111110101100011111011110000001110000001011"
bestLastGen = "100001111111111101111111111111110000000000000000101111111010110001001101110001110011110001110101000011110111101111111011111101111000000000000001101011001011000000101100010000010001100110110000010000111111111111111111011110110000011000000101011111111001010001001110000001010001100101111001111000000111101011111111000000110000000111100000110010001011001001010001111000000100100010111001101101010001000001000100111010101001010000011010001110000000000001101001100010000010010010101110000110000100010000011000100000001010011000010111111101000111111101110010110011100000010101001111"
bestLastGen = "100000111011111111111111111111110000000000000001110101011000110010010101110100100011101111011011110001111110001111111111010110110100000000000011001000011011001011100011100001010000111100100011000110111111111111111111111111110000000000000001101001110101101011000000111101110001110111011010100001010011001111111101011110111000000010010010011110001011101101100101011000110010010111111110101101000000010011110000000000010111101111111001100110111100101001100111001111010100000100010010101101000001010000001000010100101111101011111111100010101110000101101010111100110100000100010000"
bestLastGen = "100001111011111111111111111111110000000000010000001001000000100001111000110101010011100111011111111001111111011111111111010111110000000000000000001000011000011000100110101101010000101100000010000110111111111111111111111111110000000000000001000001110100001001111001100111110010110111111111100001010011111111111001011111111000000010010000011101000011001001110001111001010100010111111111111001000011010011010000000000001111010111111011101110110101001001100010000011010011000100010111100111000010010000000100000101001101111111111001110100001000110101100111000000100001000000000000"
bestLastGen = "100001111011111111111111111111110000000000000000111100011110000001101100110000010010100111111110111001111111011111111111010111110000000000000000001010110000011001100110101001110011110100100010000110111111111111111111111111110000000000000000100001110110001001101000100111110000110111111111100000010011111111111001011111111000000010010000110111110011100001110110110001010100000011101111101101000000010011010000001011001111110011111010001111110101001101100011000001110011000000010000110110000000000000010000000100001110111110111001110011010000011001011111101010100011011100000000"
bestLastGen = "001100101111100001011110011101000000100011101101000111000011000100111101100110011111001010100100000011111000000110001011101101100111010101000111101101010010110010111011010111101101101011110110101010000111010011100000100110000111110011010111111001010101101101111010100010101000000001101011011100001000101111001011001001101101110101111101111110111011011000011001011111000101100000111111110111000101110001101000100011001001001100000100111001111001000111110000101000100011001010010011101111001100011110000011110011010011100001010100111011010010100111011100111111010001110000010111"
#best 9 neurons?
bestLastGen = "001000111001001101011111111111111011010000000000101000111001001101111001110110100000010011110001001111111111111110101111100011110011110000100111110011110110111111010000100110000000010000100101101100110101111110111011101000110011001001111100101101100101100000111011011010101000000010100001111101110111111011010111110110111101000101100010010110101001000011100001111010100010010011110110000000010000111111011111111001110001101001110110100110111010011000101110111011110111101101101110100110001100010010100000101100100100101111001010110011100101010000110000101001110000011100000001"
bestLastGen = "11010111011111110011111110111111101101111001000100000000001101101100001000000101010100110100111101110111000101000100001011011000011111111011111110111111111111110001111100100011000000001011110000000010101010011111110110111100010111001110111100001000001110100101101110111111001111110011111111111111011010010101010100010111001000001110111000100100001101010100111100010001000011001011011111010110101111100111111010111100001111101111111011111110100101100010111110111001110110100001110010001110011111010001010111000111101110111000101001110101011111100000011010000101000011010001011110001010011101111001001110111010010110000101111001000001000000100011000101100011100100101110010100001100110001010000010111010000101101010010001010001100010110110111011001110110000100000111001101000000000000001000000001000000010001000101101010101001101100101000001000111111100011000000110011110110001111010010100110000111011110110010000111010001111001001011110000101011100000000011110101100011011011111100001001101111110001000100010011011111000100101111111011000000000000111100000001001000101111000001111100101100110100101010011011010001000100011001010111111010001111111110111110101011111110111001000110100000000101010101001111010111100101100100011110000101010101000010001001101111110011000011110101111101"

bestLastGen = None

visual = visualiser(LENGTH_OF_NEURON)

num_generations = 500
num_mutants = 100
rank_selection = int(num_mutants*0.3)
best_unchanged = 3
mutation_rate = 0.01
chanceOfCrossBreed = 0.3
chanceOfCompleteRandom = 0.05
min_samples_per_generation = 40
hoop_cycle_list_index = 4

def chooseDataSubset(signals):
    chosen_data = int(random()*len(signals))
    data_set = signals[chosen_data]
    length = len(data_set)
    if length < min_samples_per_generation:
        print("Not enough data!")
    index1, index2 = (int(random()*length), int(random()*length))
    while abs(index2-index1) < min_samples_per_generation:
        index1, index2 = (int(random()*length), int(random()*length))

    if index1 > index2:
        index1, index2 = (index2, index1)

    data_subset = data_set[index1:index2]
    return data_subset, chosen_data, index1, index2

seed(datetime.microsecond)

signalList = getSignalList()

a = timeDelta()
d = timeDelta()

if bestLastGen != None:
    parentDNA = BinaryStringDna(bestLastGen)
    mutantList = [parentDNA for x in range(num_mutants)]
else:
    mutantList = [BinaryStringDna() for x in range(num_mutants)]
data_subset, chosen_data, index1, index2 = chooseDataSubset(signalList)

def evalGeneration():
    #Choose a random set of data to evaluate the things on
    data_subset, chosen_data, index1, index2 = chooseDataSubset(signalList)

    #Convert the hoop trigger data to an accumulated value
    count = 0
    for i in range(len(data_subset)):
        if data_subset[i][hoop_cycle_list_index] == 1:
            count += 1
        #data_subset[i][hoop_cycle_list_index] = count*1500
        data_subset[i][hoop_cycle_list_index] = data_subset[i][hoop_cycle_list_index]*30000

    #Create a generation of mutants
    for i in xrange(rank_selection, num_mutants):
        mutantList[i] = choice(mutantList[:rank_selection])

    for i in xrange(best_unchanged, num_mutants):
        mutant = mutantList[i].getFlipMutant(mutation_rate)
        if random() < chanceOfCrossBreed:
            mutant = mutant.getCrossBreed(choice(mutantList), int(random()*LENGTH_OF_NEURON))
        if random() < chanceOfCompleteRandom:
            mutant = BinaryStringDna()
        mutantList[i] = mutant

    bestScore = 1
    for i in xrange(num_mutants):
        score = evaluateDNA(mutantList[i], data_subset)
        if score < bestScore:
            bestScore = score
        #print(score)
        mutantList[i].score = score

    mutantList = sorted(mutantList, key=lambda mutant: mutant.score)

for generation in xrange(num_generations): #Generations

    #Choose a random set of data to evaluate the things on
    data_subset, chosen_data, index1, index2 = chooseDataSubset(signalList)

    #Convert the hoop trigger data to an accumulated value
    count = 0
    for i in range(len(data_subset)):
        if data_subset[i][hoop_cycle_list_index] == 1:
            count += 1
        #data_subset[i][hoop_cycle_list_index] = count*1500
        data_subset[i][hoop_cycle_list_index] = data_subset[i][hoop_cycle_list_index]*30000

    #Create a generation of mutants
    for i in xrange(rank_selection, num_mutants):
        mutantList[i] = choice(mutantList[:rank_selection])

    #for i in xrange(best_unchanged, num_mutants):
    for i in xrange(num_mutants):
        mutant = mutantList[i].getFlipMutant(mutation_rate)
        if random() < chanceOfCrossBreed:
            mutant = mutant.getCrossBreed(choice(mutantList), int(random()*LENGTH_OF_NEURON))
        if random() < chanceOfCompleteRandom:
            mutant = BinaryStringDna()
        mutantList[i] = mutant

    try:
        priorBest
    except:
        priorBest = 0
    bestScore = 1
    for i in xrange(num_mutants):
        score = evaluateDNA(mutantList[i], data_subset)
        if score < bestScore:
            bestScore = score
        #print(score)
        mutantList[i].score = score

    mutantList = sorted(mutantList, key=lambda mutant: mutant.score)
    logString = "Generation: {: >6d} bestscore: {: >1.4f} choice: {: >2d} range {: >3d} - {: >4d} dataString: {}\n".format(generation, score, chosen_data, index1, index2, mutantList[0].dataString)
    print(logString)
    f = open("log.txt", 'w')
    f.write(logString)
    visual.collect_generation(mutantList[0].dataString, (int(mapTo(bestScore, 0, 0.45, 255, 50)), 0, int(mapTo(abs(priorBest-bestScore), 0, 0.1, 0, 255))))
    visual.build_visual()
    priorBest = bestScore